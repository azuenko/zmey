package forwarder

import (
	"fmt"

	"github.com/stratumn/zmey"
)

// Forwarder implements Process interface and runs simple forwarding algorithm
type Forwarder struct {
	pid int
	api zmey.API
}

// FCall represents a message exchanged between forwarder process and client
type FCall struct {
	// SequenceNumber is always-increasing message id
	SequenceNumber int
	// To is recepient id
	To int
	// Payload is just few randomly-generated bytes
	Payload []byte
}

// NewForwarder creates and returns the instance of Forwarder process
func NewForwarder(pid int) zmey.Process {
	return &Forwarder{pid: pid}
}

// Bind implements Process.Bind
func (f *Forwarder) Bind(api zmey.API) {
	f.api = api
}

// ReceiveNet implements Process.ReceiveNet
func (f *Forwarder) ReceiveNet(m *zmey.Message) {
	fcall, ok := m.Payload.(FCall)
	if !ok {
		f.api.ReportError(fmt.Errorf("cannot coerce to FCall: %+v", m.Payload))
		return
	}

	if fcall.To != f.pid {
		f.api.ReportError(fmt.Errorf("%d: incorrect recepient, should be %d", fcall.To, f.pid))
		return
	}

	f.api.Return(&zmey.Call{Payload: m.Payload})
}

// ReceiveCall implements Process.ReceiveCall
func (f *Forwarder) ReceiveCall(c *zmey.Call) {
	fcall, ok := c.Payload.(FCall)
	if !ok {
		f.api.ReportError(fmt.Errorf("cannot coerce to FCall: %+v", c.Payload))
		return
	}

	if fcall.To == f.pid { // Local call
		f.api.Return(c)
		return
	}

	f.api.Send(&zmey.Message{From: f.pid, To: fcall.To, Payload: fcall})
}
